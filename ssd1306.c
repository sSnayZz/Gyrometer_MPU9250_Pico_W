#include "ssd1306.h"
#include "hardware/i2c.h"
#include "pico/stdlib.h"
#include <string.h>

static void ssd1306_send_cmd(ssd1306_t *p, uint8_t cmd) {
    uint8_t buf[2] = {0x00, cmd};
    i2c_write_blocking(p->i2c_instance, p->address, buf, 2, false);
}

static void ssd1306_send_data(ssd1306_t *p, uint8_t *data, size_t len) {
    uint8_t buf[len + 1];
    buf[0] = 0x40;
    memcpy(buf + 1, data, len);
    i2c_write_blocking(p->i2c_instance, p->address, buf, len + 1, false);
}

void ssd1306_init(ssd1306_t *p, uint16_t width, uint16_t height, bool external_vcc, uint8_t address, i2c_inst_t *i2c_instance) {
    p->width = width;
    p->height = height;
    p->external_vcc = external_vcc;
    p->address = address;
    p->i2c_instance = i2c_instance;
    memset(p->buffer, 0, sizeof(p->buffer));

    uint8_t init_cmds[] = {
        0xAE,       // display off
        0xD5, 0x80, // set display clock divide ratio/oscillator frequency
        0xA8, (uint8_t)(height - 1), // set multiplex ratio
        0xD3, 0x00, // set display offset
        0x40,       // set start line at 0
        0x8D, (uint8_t)(external_vcc ? 0x10 : 0x14), // charge pump
        0x20, 0x00, // memory mode: horizontal
        0xA1,       // segment remap (flips horizontally)
        0xC8,       // COM scan direction (flips vertically)
        0xDA, (uint8_t)(height == 64 ? 0x12 : 0x02), // COM pins
        0x81, (uint8_t)(external_vcc ? 0x9F : 0xCF), // contrast
        0xD9, (uint8_t)(external_vcc ? 0x22 : 0xF1), // pre-charge
        0xDB, 0x40, // VCOM detect level
        0xA4,       // display follows RAM
        0xA6,       // normal display
        0x2E,       // deactivate scroll
        0xAF        // display on
    };

    for (uint i = 0; i < sizeof(init_cmds); i++)
        ssd1306_send_cmd(p, init_cmds[i]);
}

void ssd1306_clear(ssd1306_t *p) {
    memset(p->buffer, 0, sizeof(p->buffer));
}

void ssd1306_draw_pixel(ssd1306_t *p, int x, int y, bool color) {
    if (x < 0 || x >= p->width || y < 0 || y >= p->height) return;
    int byte_index = x + (y / 8) * p->width;
    if (color)
        p->buffer[byte_index] |= (1 << (y & 7));
    else
        p->buffer[byte_index] &= ~(1 << (y & 7));
}

void ssd1306_show(ssd1306_t *p) {
    ssd1306_send_cmd(p, 0x21); // set column address
    ssd1306_send_cmd(p, 0);
    ssd1306_send_cmd(p, p->width - 1);
    ssd1306_send_cmd(p, 0x22); // set page address
    ssd1306_send_cmd(p, 0);
    ssd1306_send_cmd(p, (p->height / 8) - 1);
    ssd1306_send_data(p, p->buffer, p->width * (p->height / 8));
}

// Police 5x8 basique ASCII 32–127
static const uint8_t font[] = {
    0x00,0x00,0x00,0x00,0x00, // (espace)
    0x00,0x00,0x5F,0x00,0x00, // !
    0x00,0x07,0x00,0x07,0x00, // "
    0x14,0x7F,0x14,0x7F,0x14, // #
    0x24,0x2A,0x7F,0x2A,0x12, // $
    0x23,0x13,0x08,0x64,0x62, // %
    0x36,0x49,0x55,0x22,0x50, // &
    0x00,0x05,0x03,0x00,0x00, // '
    0x00,0x1C,0x22,0x41,0x00, // (
    0x00,0x41,0x22,0x1C,0x00, // )
    0x14,0x08,0x3E,0x08,0x14, // *
    0x08,0x08,0x3E,0x08,0x08, // +
    0x00,0x50,0x30,0x00,0x00, // ,
    0x08,0x08,0x08,0x08,0x08, // -
    0x00,0x60,0x60,0x00,0x00, // .
    0x20,0x10,0x08,0x04,0x02, // /
    0x3E,0x51,0x49,0x45,0x3E, // 0
    0x00,0x42,0x7F,0x40,0x00, // 1
    0x42,0x61,0x51,0x49,0x46, // 2
    0x21,0x41,0x45,0x4B,0x31, // 3
    0x18,0x14,0x12,0x7F,0x10, // 4
    0x27,0x45,0x45,0x45,0x39, // 5
    0x3C,0x4A,0x49,0x49,0x30, // 6
    0x01,0x71,0x09,0x05,0x03, // 7
    0x36,0x49,0x49,0x49,0x36, // 8
    0x06,0x49,0x49,0x29,0x1E, // 9
    0x00,0x36,0x36,0x00,0x00, // :
    0x00,0x56,0x36,0x00,0x00, // ;
    0x08,0x14,0x22,0x41,0x00, // <
    0x14,0x14,0x14,0x14,0x14, // =
    0x00,0x41,0x22,0x14,0x08, // >
    0x02,0x01,0x51,0x09,0x06, // ?
    0x32,0x49,0x79,0x41,0x3E, // @
    0x7E,0x11,0x11,0x11,0x7E, // A
    0x7F,0x49,0x49,0x49,0x36, // B
    0x3E,0x41,0x41,0x41,0x22, // C
    0x7F,0x41,0x41,0x22,0x1C, // D
    0x7F,0x49,0x49,0x49,0x41, // E
    0x7F,0x09,0x09,0x09,0x01, // F
    0x3E,0x41,0x49,0x49,0x7A, // G
    0x7F,0x08,0x08,0x08,0x7F, // H
    0x00,0x41,0x7F,0x41,0x00, // I
    0x20,0x40,0x41,0x3F,0x01, // J
    0x7F,0x08,0x14,0x22,0x41, // K
    0x7F,0x40,0x40,0x40,0x40, // L
    0x7F,0x02,0x0C,0x02,0x7F, // M
    0x7F,0x04,0x08,0x10,0x7F, // N
    0x3E,0x41,0x41,0x41,0x3E, // O
    0x7F,0x09,0x09,0x09,0x06, // P
    0x3E,0x41,0x51,0x21,0x5E, // Q
    0x7F,0x09,0x19,0x29,0x46, // R
    0x46,0x49,0x49,0x49,0x31, // S
    0x01,0x01,0x7F,0x01,0x01, // T
    0x3F,0x40,0x40,0x40,0x3F, // U
    0x1F,0x20,0x40,0x20,0x1F, // V
    0x3F,0x40,0x38,0x40,0x3F, // W
    0x63,0x14,0x08,0x14,0x63, // X
    0x07,0x08,0x70,0x08,0x07, // Y
    0x61,0x51,0x49,0x45,0x43, // Z
    0x00,0x7F,0x41,0x41,0x00, // [
    0x02,0x04,0x08,0x10,0x20, // backslash
    0x00,0x41,0x41,0x7F,0x00, // ]
    0x04,0x02,0x01,0x02,0x04, // ^
    0x40,0x40,0x40,0x40,0x40, // _
    0x00,0x03,0x05,0x00,0x00, // `
    0x20,0x54,0x54,0x54,0x78, // a
    0x7F,0x48,0x44,0x44,0x38, // b
    0x38,0x44,0x44,0x44,0x20, // c
    0x38,0x44,0x44,0x48,0x7F, // d
    0x38,0x54,0x54,0x54,0x18, // e
    0x08,0x7E,0x09,0x01,0x02, // f
    0x08,0x54,0x54,0x54,0x3C, // g
    0x7F,0x08,0x04,0x04,0x78, // h
    0x00,0x44,0x7D,0x40,0x00, // i
    0x20,0x40,0x44,0x3D,0x00, // j
    0x7F,0x10,0x28,0x44,0x00, // k
    0x00,0x41,0x7F,0x40,0x00, // l
    0x7C,0x04,0x18,0x04,0x78, // m
    0x7C,0x08,0x04,0x04,0x78, // n
    0x38,0x44,0x44,0x44,0x38, // o
    0x7C,0x14,0x14,0x14,0x08, // p
    0x08,0x14,0x14,0x18,0x7C, // q
    0x7C,0x08,0x04,0x04,0x08, // r
    0x48,0x54,0x54,0x54,0x20, // s
    0x04,0x3F,0x44,0x40,0x20, // t
    0x3C,0x40,0x40,0x20,0x7C, // u
    0x1C,0x20,0x40,0x20,0x1C, // v
    0x3C,0x40,0x30,0x40,0x3C, // w
    0x44,0x28,0x10,0x28,0x44, // x
    0x0C,0x50,0x50,0x50,0x3C, // y
    0x44,0x64,0x54,0x4C,0x44, // z
    0x00,0x08,0x36,0x41,0x00, // {
    0x00,0x00,0x7F,0x00,0x00, // |
    0x00,0x41,0x36,0x08,0x00, // }
    0x10,0x08,0x08,0x10,0x08  // ~
};


void ssd1306_draw_char(ssd1306_t *p, int x, int y, char c, bool color)
{
    if (c < 32 || c > 127) return; // caractères ASCII imprimables uniquement

    for (int i = 0; i < 5; i++) {
        uint8_t line = font[(c - 32) * 5 + i];
        for (int j = 0; j < 8; j++) {
            if (line & 1)
                ssd1306_draw_pixel(p, x + i, y + j, color);
            line >>= 1;
        }
    }
}


void ssd1306_draw_string(ssd1306_t *p, int x, int y, bool color, const char *str) {
    while (*str) {
        ssd1306_draw_char(p, x, y, *str++, color);
        x += 6; // espace entre caractères
    }
}
